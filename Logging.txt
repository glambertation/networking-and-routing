2016/4/15
小婷advice
十字图

小组讨论
集中器：
1.获取簇头的信息：发询问帧给簇头（广播形式，不知簇头的物理地址）：得到簇头的ip（自己人为定义，路由表），添加到自己的路由

小问题：
我知道所有所有的物理地址（随硬件做了就定了）


==============
2016/4/14

邵萌：
1.wifi判断上行 设置为1
2.帧发给服务器端，服务器端程序自己写自己解析


==============
48,0,0,12288,0,0,4  publish
208,0,0,53248,0,0,4 pingresq
=========
1.先组网-组网完优化路由-dijkstra算法（突然觉得这个也挺简单的）
2.如果简单好用的话，就组网-测试


====================

论文有趣点：
1.如果中继地址和自己的 ID 相同，则转发这个报文
（同时中继地址 目的地址 这样减少命令帧设计）
2.集中器测信噪比
3.集中器在时间Tm 内收到终端的应答报文后，先检验通信信号的信噪比，如果信号信噪比满足预先设定的条件，则记录下终端地址以及相应的通信信号信噪比。把在第一轮中所有满足条件的终端列为逻辑层 1（Layer 1）；
4.组网全部在集中器中完成，对设备的要求较低，除集中器外，其余终端只要求具有信号的接收和转发功能，简化了设备的硬件结构，

论文疑问点：
1.数据帧结构，论文说参考多功能电表通信协议。我们目前组网程序里的数据帧是自己写的，这个随时可以改没有问题，但是想尽量写的简单。
所以想请问数据帧结构必须参考多功能电表通信协议吗？我们自定义可行不？还是说它涉及到上层传输？
我想只是节点与集中器，节点与节点通信，那自定义数据帧在这两种传输中是可以相互识别的，因为这个算最底层，直接拆帧就可以读取上层传输的信息了。
但我们通信范围涉及【 集中器直接和非节点直接通信吗】？

2.论文里集中器，我不了解用什么硬件实现...
我们的组网程序是直接移植到集中器上吗？还是说，集中器就是我们的开发板+检测信噪比模块？


===================================
小疑问点：stm32是全双工，但是程序实现里是先平再recv，如何保持时刻监听？
而且usart貌似是自己时刻监听，然后把收到的数据储存在usart_rx_buf[]里，然而我们这样定期处理会不会有问题。




主节点逻辑：
1.每一分钟发送一次ping帧（目前只写了广播短帧）
2.收到pingack后，将子节点id存入自己路由表（多叉树）中
3.给子节点发送请求亮1灯（升级主从）下行消息
4.时刻监听

子1节点逻辑：
1.时刻监听
2.收到ping帧后，存入主节点id 给主节点id发送pingack
3.时刻监听
4.收到主节点发给自己要求亮1灯消息
5.亮1灯
6.升级为主从节点
7.每一分钟发送一次ping帧（目前只写了广播短帧）
8.收到pingack后，将子节点id存入自己路由表（多叉树）中
9.给子节点发送请求亮灯（升级主从）下行消息
10.时刻监听

子2节点逻辑：
1.时刻监听
2.收到ping帧后，存入主节点id 给主节点id发送pingack
3.时刻监听
4.收到主节点发给自己要求亮2灯消息
5.亮2灯


目前只写了ping帧广播短帧，还需要写广播长帧

========================
2016/4/13
弥强
packetk可以设成char【】数组形式，上层解析
目前只有一条路通达，不需要算法
电力线 单播就算广播，全f设置
id改成同一字段的网络号
测跳通时，手工屏蔽接受到的信号
子节点发送链路状态给父节点，这样全网通，然后逐层遍历，最后一层有mid就发，主节点没有收到回馈就重发
用ping短帧，长帧来衡量链路状态---对应qos

问：
1.后期上层时，只有对应stm32可以解析自己写的数据帧，那么如何推送信息给手机端
2.写多叉树的意义是啥，我为啥不直接把子节点id存到字符串或者数组里呢？


=============

2016/4/12
【todo】：htnol网络字节数转换

节点自己子节点遍历查找ok！

========================================
2016/4/11
【TODO】：idea:
因为每当网络状态发生变化时，系统就会发出一条值为android.net.conn.CONNECTIVITY_CHANG的广播。

=================
2016/4/7
路由思路，参考ospf：1：像本自治系统中所有路由器发送信息（flooding）
                    2.发送信息是与本路由器相邻的所有路由器的链路状态，包括metric（通                       信情况好不好）
                    3.只有放链路状态发生变化时，才向所有路由器发送flooding


=====================
2016/4/6
路由表改成双链表，删除写完
git备份

===========
2016/3/31
路由表同一父节点插入（单链表）

下面要写路由表删除，更新

===============

2016/3/28
字符串切分ok，路由表struct简单版（以后改）
pingack，直接套用pingreq，先_send_simple_command(PINGRESP)，
                            _packet_queue(command, packet, 0, 0);

pingreq是_send_simple_command(PINGREQ)，
         _packet_queue(command, packet, 0, 0);
         队列中，mpkt。mid给自己赋值，字符串拼接，传到_out_packet和current_out_packet

usart的收完后，应有添加一步存数据


======================================
2016/3/21
usart recv弄完

=========================================
2016/3/17
ping短帧send写完，rec有待改进，
字符串拼接get
尚未测试
问题：日志，错误机制，队列，多线程


=======================================
2016/3/15
htons网络字符转换
time（0）：用秒数表达
改完了send-ping（调用send-simple-command转换网络字符）
send-simple-command 返回了packet队列，队列无失误的话，返回succces=0 return0
packet-queue
设定了一个结构体，来满足dict功能，不过后期可能需要读位来定

线程没有看，注释掉了
_current_out_packet=none，那么数据格式怎么设定呢